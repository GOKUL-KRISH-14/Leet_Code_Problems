package com.problems.binarysearch;

/*

1. Leet Code Problem Number :- 33
2. Leet Code Problem Name :- Search In Rotated Array

There is an integer array nums sorted in ascending order (with distinct values).

Prior to being passed to your function, nums is possibly rotated at an unknown pivot 
index k (1 <= k < nums.length) such that the resulting array is 
[nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]] (0-indexed). 

For example, [0,1,2,4,5,6,7] might be rotated at pivot index 3 and become [4,5,6,7,0,1,2].

Given the array nums after the possible rotation and an integer target, return the index of target if it is in nums, or -1 if it is not in nums.
You must write an algorithm with O(log n) runtime complexity.

Example 1:

Input: nums = [4,5,6,7,0,1,2], target = 0
Output: 4

Complexity :-

 */

public class Search_In_Rotated_Array 
{
	public static int searchArray(int nums[],int target)
	{
		// Initialize the search window
		int left=0;
		int right=nums.length-1;
		
		 // Perform binary search
		while(left<=right)
		{
			int mid=(left+right)/2;
			
			// If target found at mid
			if(nums[mid]==target)
			{
				return mid;
			}
			
			// Check if the left half is sorted
			if(nums[left]<=nums[mid])
			{
				// Target lies in the sorted left half
				if(nums[left]<=target && target<=nums[mid])
				{
					// Narrow search to left half
					right=mid-1;
				}
				else
				{
			    // Discard left half
				left=mid+1;
				}
			}
			
			 // Else, the right half is sorted
			else
			{
				// Target lies in the sorted right half
				if(nums[mid]<=target && target<=nums[right])
				{
					// Narrow search to right half
					left=mid+1;
				}
				else
				{
				// Discard right half
				right=mid-1;
				}
			}
		}
		return -1;
	}
	package com.problems.binarysearch;

	public class Search_In_Rotated_Array 
	{
	    // Function to search for the target in rotated sorted array
	    public static int searchArray(int nums[], int target)
	    {
	        int left = 0;
	        int right = nums.length - 1;

	        while (left <= right)
	        {
	            int mid = (left + right) / 2;

	            // If the middle element is the target
	            if (nums[mid] == target)
	            {
	                return mid;
	            }

	            // Check if the left half is sorted
	            if (nums[left] <= nums[mid])
	            {
	                // Target lies within the left half
	                if (nums[left] <= target && target < nums[mid])
	                {
	                    right = mid - 1;
	                }
	                else
	                {
	                    left = mid + 1;
	                }
	            }
	            // Right half must be sorted
	            else
	            {
	                // Target lies within the right half
	                if (nums[mid] < target && target <= nums[right])
	                {
	                    left = mid + 1;
	                }
	                else
	                {
	                    right = mid - 1;
	                }
	            }
	        }

	        // Target not found
	        return -1;
	    }

	    // Main method for testing the function
	    public static void main(String[] args)
	    {
	        int[] nums = {4, 5, 6, 7, 0, 1, 2};
	        int target = 0;

	        int index = searchArray(nums, target);
	        if(index != -1)
	        {
	            System.out.println("Target " + target + " found at index: " + index);
	        }
	        else
	        {
	            System.out.println("Target " + target + " not found in the array.");
	        }
	    }
	}


