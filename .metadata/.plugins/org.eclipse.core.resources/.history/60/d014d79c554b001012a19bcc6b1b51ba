package com.problems.binarysearch;

/*
Given two sorted arrays nums1 and nums2 of size m and n respectively, 
return the median of the two sorted arrays.

The overall run time complexity should be O(log (m+n)).

 */


public class Median_Of_Two_Sorted_Arrays 
{
	public static double medianArrays(int nums1[],int nums2[])
	{
		if(nums1.length>nums2.length)
		{
			return medianArrays(nums2,nums1);
		}
		
		int m=nums1.length;
		int n= nums2.length;
		
		int low=0;
		int high=m;
		
		while(low<=high)
		{
			int partition_X=(low+high)/2;
			int partition_Y=(m+n+1)/2-partition_X;
			
			
			int maxLeftX=(partition_X==0)?Integer.MIN_VALUE:nums1[partition_X-1];
			int minRightX=(partition_X==m)?Integer.MAX_VALUE:nums1[partition_X];
			
			int maxLeftY=(partition_Y==0)?Integer.MIN_VALUE:nums1[partition_Y-1];
			int minRightY=(partition_Y==n)?Integer.MAX_VALUE:nums1[partition_Y];
			
			
			while(maxLeftX<=minRightY && maxLeftY<=minRightY)
			{
				if (maxLeftX <= minRightY && maxLeftY <= minRightX) 
				{
	                // Found correct partition
	                if ((m + n) % 2 == 0) {
	                    return ((double)Math.max(maxLeftX, maxLeftY) + Math.min(minRightX, minRightY)) / 2;
	                } 
	                else 
	                {
	                    return (double)Math.max(maxLeftX, maxLeftY);
	                }
	                
				   } else if (maxLeftX > minRightY) 
				   {
		                // Too far on the right side of nums1, move left
		                high = partition_X - 1;
		            } 
				   else 
		            {
		                // Too far on the left side of nums1, move right
		                low = partition_X + 1;
		            }
			}
			throw new IllegalArgumentException("Input arrays are not sorted.");
		}
		
		
		
		
		
	}

}
